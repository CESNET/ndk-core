#!/bin/python3

#  SPDX-License-Identifier: BSD-3-Clause
#
#  simple pakcet generator. Packet are generated by random walk.
#  In this file is resolving how prototoclols follows.
#
#  Copyright (C) 2022 CESNET
#  Author(s):
#    Radek IÅ¡a <isa@cesnet.cz>

from config import *
import scapy.all
import scapy.utils
import scapy.contrib.mpls
import random
import string
import ipaddress

class base_node:
    def __init__(self, name):
        self.name = name

    def protocol_add(self, config):
        pass

    def protocol_next(self, config):
        return None



#################################
# PAYLOAD protocols
#################################
class Empty(base_node):
    def __init__(self):
        super().__init__("Empty");

class Payload(base_node):
    def __init__(self):
        super().__init__("Payload");

    def protocol_add(self, config):
        return scapy.all.Raw()


#################################
# L7 protocols
#################################
class ICMPv4(base_node):
    def __init__(self):
        super().__init__("ICMPv4");

    def protocol_add(self, config):
        return scapy.all.ICMP()

    def protocol_next(self, config):
        return None


class ICMPv6(base_node):
    def __init__(self):
        super().__init__("ICMPv6");

    def protocol_add(self, config):
        return scapy.all.ICMPv6Unknown()

    def protocol_next(self, config):
        return None

class UDP(base_node):
    def __init__(self):
        super().__init__("UDP");

    def protocol_add(self, config):
        return scapy.all.UDP()

    def protocol_next(self, config):
        proto = { "Empty" : 1, "Payload" : 1 }
        cfg_obj = config.object_get([self.name, "weight"])
        if (cfg_obj != None):
            proto.update(cfg_obj);
        return proto


class TCP(base_node):
    def __init__(self):
        super().__init__("TCP");

    def protocol_add(self, config):
        return scapy.all.TCP()

    def protocol_next(self, config):
        proto = { "Empty" : 1, "Payload" : 1 }
        proto_weight = config.object_get([self.name, "weight"]);
        if (proto_weight != None):
            proto.update(proto_weight)
        return proto

#################################
# IP protocols
#################################
class IPv4(base_node):
    def __init__(self):
        super().__init__("IPv4");

    def protocol_add(self, config):
        src = None;
        dst = None;

        src_rand = config.object_get([self.name, "values", "src"]);
        if (src_rand != None):
            val_range = random.choice(src_rand)
            src_min = int(val_range.get("min"), 0)
            src_max = int(val_range.get("max"), 0)
            src = str(ipaddress.IPv4Address(random.randint(src_min, src_max)))

        dst_rand = config.object_get([self.name, "values", "dst"]);
        if (dst_rand != None):
            val_range = random.choice(dst_rand)
            dst_min = int(val_range.get("min"), 0)
            dst_max = int(val_range.get("max"), 0)
            dst = str(ipaddress.IPv4Address(random.randint(dst_min, dst_max)))

        return scapy.all.IP(version=4, src = src, dst = dst)

    def protocol_next(self, config):
        proto = { "Payload" : 1, "Empty" : 1, "ICMPv4" : 1, "UDP" : 1, "TCP" : 1}
        proto_weight = config.object_get([self.name, "weight"]);
        if (proto_weight != None):
            proto.update(proto_weight)
        return proto


class IPv6(base_node):
    def __init__(self):
        super().__init__("IPv6");

    def protocol_add(self, config):
        src = None;
        dst = None;

        src_rand = config.object_get([self.name, "values", "src"]);
        if (src_rand != None):
            val_range = random.choice(src_rand)
            src_min = int(val_range.get("min"), 0)
            src_max = int(val_range.get("max"), 0)
            src = str(ipaddress.IPv6Address(random.randint(src_min, src_max)))

        dst_rand = config.object_get([self.name, "values", "dst"]);
        if (dst_rand != None):
            val_range = random.choice(dst_rand)
            dst_min = int(val_range.get("min"), 0)
            dst_max = int(val_range.get("max"), 0)
            dst = str(ipaddress.IPv6Address(random.randint(dst_min, dst_max)))

        return scapy.all.IPv6(version=6, src = src, dst = dst)


    def protocol_next(self, config):
        proto = { "Payload" : 1, "Empty" : 1, "ICMPv4" : 1, "UDP" : 1, "TCP" : 1}
        proto_weight = config.object_get([self.name, "weight"]);
        if (proto_weight != None):
            proto.update(proto_weight)
        return proto

#################################
# ETHERNET protocols
#################################
class MPLS(base_node):
    def __init__(self):
        super().__init__("MPLS");

    def protocol_add(self, config):
        return scapy.contrib.mpls.MPLS()

    def protocol_next(self, config):
        proto   = {"IPv4" : 1, "IPv6" : 1, "MPLS" : 1,"Empty" : 1}
        proto_weight = config.object_get([self.name, "weight"]);
        if (proto_weight != None):
            proto.update(proto_weight)
        # Check if it is last generated MPLS
        if (config.mpls != 0):
            config.mpls -= 1
        if (config.mpls == 0):
            proto["MPLS"] = 0;

        return proto


class PPP(base_node):
    def __init__(self):
        super().__init__("PPP");

    def protocol_add(self, config):
        return scapy.all.PPP()

    def protocol_next(self, config):
        proto = {"IPv4" : 1, "IPv6" : 1, "MPLS" : 1, "Empty" : 1}
        proto_weight = config.object_get([self.name, "weight"]);
        if (proto_weight != None):
            proto.update(proto_weight)

        return proto



class VLAN(base_node):
    def __init__(self):
        super().__init__("VLAN");

    def protocol_add(self, config):
        return scapy.all.Dot1Q()

    def protocol_next(self, config):
        proto   = {"IPv4" : 1, "IPv6" : 1, "VLAN" : 1 , "MPLS" : 1, "Empty" : 1, "PPP" : 1}
        proto_weight = config.object_get([self.name, "weight"]);
        if (proto_weight != None):
            proto.update(proto_weight)
        # check if it is last generated VLAN
        if (config.vlan != 0):
            config.vlan -= 1
        if (config.vlan == 0):
            proto_weight["VLAN"] = 0;

        return proto


class ETH(base_node):
    def __init__(self):
        super().__init__("ETH");

    def protocol_add(self, config):
        return scapy.all.Ether()

    def protocol_next(self, config):
        proto = {"IPv4" : 1, "IPv6" : 1, "VLAN" : 1, "MPLS" : 1, "Empty" : 1, "PPP" : 1}
        proto_weight = config.object_get([self.name, "weight"]);
        if (proto_weight != None):
            proto.update(proto_weight)

        return proto


class parser:
    def __init__(self, pcap_file, cfg, seed):
        self.protocols = {"ETH" : ETH(), "VLAN" : VLAN(), "PPP" : PPP(), "MPLS" : MPLS(), "IPv6" : IPv6(),
                          "IPv4" : IPv4(), "TCP" : TCP(), "UDP" : UDP(), "ICMPv6" : ICMPv6(), "ICMPv4" : ICMPv4(),
                          "Payload" : Payload(), "Empty" : Empty()};
        self.pcap_file = scapy.utils.PcapWriter(pcap_file, append=False, sync=True)
        self.cfg = None
        if (cfg != None):
            conf_file = open(cfg)
            self.cfg  = conf_file.read()
            conf_file.close();
        random.seed(seed)

    
    def __del__(self):
        self.pcap_file.close()

    def gen(self):
        pass

    def proto_weight_get(self, proto, weight, dict_items):
        for key in dict_items:
            proto.append(key);
            weight.append(dict_items[key]);


    def write(self, packet):
        packet_fuzz = scapy.packet.fuzz(packet)
        try:
            self.pcap_file.write(packet_fuzz)
        except:
            self.pcap_file.write(packet)

