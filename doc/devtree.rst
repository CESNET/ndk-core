.. _ndk_devtree:

Device Tree
-----------

Using `the Device Tree <https://www.kernel.org/doc/html/latest/devicetree/index.html>`_ (DT), we describe the contents of the firmware for the utility software: base addresses, versions and features of the individual components. To a certain extent, the Device Tree communicates to the user basic information about the HW platform, firmware version, etc. The Device Tree structure will be closely linked to a specific firmware - integrated inside.

DT integration in build system
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are scripts in the translation system that go through components using ``Modules.tcl``. The top-level ``DevTree.tcl`` script (in ofm/build) first inserts general information in the form of DT-properties into the DTS framework (build time, current repository revision, author of the firmware build, etc.). Then, if it exists, it calls a function called ``dts_build_project``, and it calls the ``dts_build_netcope`` function, which should be included in each base of the card project (typically a top-level directory with ``fpga_common.vhd``). Here, the card project already ensures the insertion of specific information (eg card type) itself, including the instancing of its subcomponents (typically ``dts_boot_controller``, ``dts_dma_module``, ``dts_application``...) and passing generics to these functions.

After running make (for compiling the firmware of the selected card) a file ``DevTree.dts`` (generated by passing TCL scripts ``DevTree.tcl``) and VHDL package ``DevTree.vhd`` are created, which contains std_logic_vector ``DTB_DATA`` (which is a binary representation of compiled (`dtc <https://github.com/dgibson/dtc/tree/main/libfdt>`_) and compressed (`xz <https://www.kernel.org/doc/html/latest/staging/xz.html>`_) input ``DevTree.dts`` file). This package is used by the ``PCI_EXT_CAP`` component, see the next chapter.

Because constants in packages cannot be accessed directly in TCL, the ``user_const.vhd`` package files are generated by the TCL script ``user_const.tcl``. This is the only way to ensure consistency in top-level generations and Device Tree descriptions. Translation scripts need `the dtc compiler <https://github.com/dgibson/dtc/tree/main/libfdt>`_ for their operation.

Location of DTB in the firmware
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The DT blob is located in the PCI configuration space. A custom extension (PCIe VSEC - Vendor-Specific Extended Capability) has been created. Because the configuration space is relatively small, there are only a few control registers that make the entire DTB stored in BRAM accessible. In this way, the DTB does not load the MI bus and cannot be easily or accidentally removed from the design. You can use the dtc tool to read the complete Device Tree from the FPGA card:

.. code:: bash

    # dtc -I dtb /dev/nfb0

Example of DTS of one component
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: dts

    /*
     * ref_name:   instance name, typically populated by the parent module when needed
     *             get reference to the installed component (can be empty)
     * my_comp:    component name, populates the dts_my_comp function
     * reg:        component address space
     *             - the first value indicates the base address on the MI,
     *             - the second value indicates the internal space size used
     * compatible: a driver submodule or software tool is bound to this string
     *             There must be a node specification for a specific compatible string:
     *             - properties and subnode names
     *             - their types and connection to HW functionality
     *             - mandatory or optional items
     *             no SW tool works directly with node without compatible property
     * version:    version of the component in terms of SW interface (register functions)
     * type:       additional / optional property
     *             - can specify large changes in the component
     *             - possibly extends the property compatible
     * others:     other properties / subnodes that the software can use
    */

    ref_name: my_comp {
        reg = <$BASE_ADDRESS 0x40>;
        compatible = "netcope,my_comp";
        version = <0x00010004>;
        type = "reduced";
    };

Example of generated DTS for FPGA card (DK-DEV-1SDX-P)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: dts

    /dts-v1/;

    / {

        firmware {
            build-tool = "Quartus $quartus(version)";
            build-author = "cabal@cesnet.cz";
            build-revision = "ff3f73b";
            build-time = <0x6143474c>;
            card-name = "DK-DEV-1SDX-P";
            project-name = "DK-DEV-1SDX-P";

            mi0: mi_bus0 {
                #address-cells = <0x01>;
                #size-cells = <0x01>;
                compatible = "netcope,bus,mi";
                resource = "PCI0,BAR0";
                width = <0x20>;

                tsu: tsu {
                    compatible = "netcope,tsu";
                    reg = <0x4000 0x1000>;
                    type = <0x01>;
                    version = <0x01>;
                };

                dma_module@0x01000000 {
                    #address-cells = <0x01>;
                    #size-cells = <0x01>;

                    dma_ctrl_ndp_rx0 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000000 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_rx1 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000080 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_rx2 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000100 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_rx3 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000180 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_rx4 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000200 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_rx5 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000280 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_rx6 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000300 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_rx7 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000380 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_tx0 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200000 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_tx1 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200080 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_tx2 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200100 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_tx3 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200180 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_tx4 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200200 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_tx5 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200280 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_tx6 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200300 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };

                    dma_ctrl_ndp_tx7 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200380 0x80>;
                        version = <0x20000>;
                        pcie = <0x00>;
                    };
                };

                i2c0: i2c0 {
                    compatible = "netcope,i2c";
                    reg = <0x800010 0x08>;
                    phandle = <0x01>;
                };

                pmd0: pmd0 {
                    compatible = "netcope,transceiver";
                    type = "QSFP";
                    control = <0x01>;
                    phandle = <0x02>;

                    control-param {
                        i2c-addr = <0xf0>;
                    };
                };

                txmac0: txmac0 {
                    compatible = "netcope,txmac";
                    type = "tx_mac_lite";
                    speed = "100";
                    version = <0x02>;
                    reg = <0x8000 0x200>;
                    mtu = <0x3fff>;
                    phandle = <0x04>;
                };

                rxmac0: rxmac0 {
                    compatible = "netcope,rxmac";
                    type = "rx_mac_lite";
                    speed = "100";
                    version = <0x02>;
                    reg = <0x8200 0x200>;
                    mtu = <0x3fff>;
                    phandle = <0x03>;
                };

                eth0 {
                    compatible = "netcope,eth";
                    pmd = <0x02>;
                    rxmac = <0x03>;
                    txmac = <0x04>;
                };

                i2c1: i2c1 {
                    compatible = "netcope,i2c";
                    reg = <0x800110 0x08>;
                    phandle = <0x05>;
                };

                pmd1: pmd1 {
                    compatible = "netcope,transceiver";
                    type = "QSFP";
                    control = <0x05>;
                    phandle = <0x06>;

                    control-param {
                        i2c-addr = <0xf8>;
                    };
                };

                txmac1: txmac1 {
                    compatible = "netcope,txmac";
                    type = "tx_mac_lite";
                    speed = "100";
                    version = <0x02>;
                    reg = <0xa000 0x200>;
                    mtu = <0x3fff>;
                    phandle = <0x08>;
                };

                rxmac1: rxmac1 {
                    compatible = "netcope,rxmac";
                    type = "rx_mac_lite";
                    speed = "100";
                    version = <0x02>;
                    reg = <0xa200 0x200>;
                    mtu = <0x3fff>;
                    phandle = <0x07>;
                };

                eth1 {
                    compatible = "netcope,eth";
                    pmd = <0x06>;
                    rxmac = <0x07>;
                    txmac = <0x08>;
                };

                adc_sensors {
                    reg = <0x1000 0x7c>;
                    compatible = "netcope,stratix_adc_sensors";
                };

                app: nic_application {
                    reg = <0x2000000 0x10>;
                };
            };

            mi1: mi_bus1 {
                #address-cells = <0x01>;
                #size-cells = <0x01>;
                compatible = "netcope,bus,mi";
                resource = "PCI1,BAR0";
                width = <0x20>;

                dma_module@0x01000000 {
                    #address-cells = <0x01>;
                    #size-cells = <0x01>;

                    dma_ctrl_ndp_rx0 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000000 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_rx1 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000080 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_rx2 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000100 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_rx3 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000180 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_rx4 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000200 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_rx5 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000280 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_rx6 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000300 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_rx7 {
                        compatible = "netcope,dma_ctrl_ndp_rx";
                        reg = <0x1000380 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_tx0 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200000 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_tx1 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200080 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_tx2 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200100 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_tx3 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200180 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_tx4 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200200 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_tx5 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200280 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_tx6 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200300 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };

                    dma_ctrl_ndp_tx7 {
                        compatible = "netcope,dma_ctrl_ndp_tx";
                        reg = <0x1200380 0x80>;
                        version = <0x20000>;
                        pcie = <0x01>;
                    };
                };
            };
        };
    };

.. note::

    The phandle is a unique identifier of the (parent) node within one DTS. With this mechanism, nodes can be referenced in any properties.

Requirements for developers
^^^^^^^^^^^^^^^^^^^^^^^^^^^

- Requirements for SW developers:
    - The developer must know the basic structure of the Device Tree.
    - Must be familiar with the functions of the libfdt library.
    - Must know the DT node specification of the component for which the utility software writes.

- Requirements for HW developers:
    - The developer must know the basic syntax of DTS to implement the unique ``dts_my_comp`` function for his component.
    - Specifies a compatible string, ie creates a description of each "property" (or "subnode") of the Device Tree for the SW developer so that the control software can write according to them.
    - It must take into account any generic parameters that change the MI address space of a component or the function of its registers. Such parameters and features must be included in the DTS so that the utility software can work with it properly.
    - Generics that do not change the address space should not be included in the component's DTS node. Component modifications and bug fixes that do not change the address space should also not be included in the DT description, because they can be found from the revision (which is one of the basic properties of the DT project). However, it is possible to consider, for example, to increase the minor version number, if the property version is present.
    - Implements ``dts_my_comp`` ideally as a function in ``DevTree.tcl``, which is implemented using ``source $ENTITY_BASE/DevTree.tcl`` in ``Modules.tcl``. It is necessary to comment well on the input parameters and inform about the default values.
    - When changing a generic that changes the address space, the developer must also update the DT description of the component or the DT description specification. Changes to the VHDL generic and its default values ​​must match the values ​​in the DT description. Otherwise, it is a bug in the firmware.
    - If it instantiates a subcomponent in its component that contains another ``dts_my_comp`` function, it should include (call) it in its description as well. In this case, it must correctly pass the base addresses and all other generics required by the ``dts_my_comp`` function. This is especially important for a top-level project where the main components are installed.
